∏(l) = (length(l)==0) ? 1 : prod(l)

∑(l) = (length(l)==0) ? 0 : sum(l)

function prod_dict(d1,d2)
    @assert keytype(d1)<:Tuple && valtype(d1)<:Vector
    @assert keytype(d2)<:Tuple && valtype(d2)<:Vector
    Dict(tuplejoin(k1,k2)=>vcat(d1[k1],d2[k2]) for k1 ∈ keys(d1) for k2 ∈ keys(d2))
end


KL2d_ord1 = Dict(()=>Vector{Int64}[], (:kx,)=>[[1,0],],   (:ky,)=>[[0,1],]  )

function MakeKL2d(ord)
    if ord==1
        return KL2d_ord1
    else
        dtmp = MakeKL2d(ord-1)
        return Dict( prod_dict(dtmp, KL2d_ord1) ∪ dtmp )
    end
end


KL3d_ord1 = Dict(()=>Vector{Int64}[], (:kx,)=>[[1,0,0],], (:ky,)=>[[0,1,0],], (:kz,)=>[[0,0,1],])

function MakeKL3d(ord)
    if ord==1
        return KL3d_ord1
    else
        dtmp = MakeKL3d(ord-1)
        return Dict( prod_dict(dtmp, KL3d_ord1) ∪ dtmp )
    end
end


#XXX Dynamical matrix kp expansion contains even orders of k
#@inline filter_even_order(KL::Dict) = Dict(k=>v for (k,v) ∈ KL if length(k)%2==0)

# ∇()
# for each term (Bravaismn, Mat) in matdic
# compute the coefficient (i k0 Bravaismn) * ... * (i k0 Bravaismn) * exp(i k0 Bravaismn)
# and multiply it on Mat
# then sum
function ∇(
    matdic::Dict,
    k0::Vector,
    klist::Vector,
    a::Coordinates
    )
    # klist is the value in the dictionary
    # generated by MakeKL3d/MakeKL2d
    order = length(klist)
    # exp(i k (m R1 + n R2))
    @inline ph(Bravaismn) = cis(k0⋅(a*Bravaismn))
    #
    @inline coeff(dk,Bravaismn) = dk⋅(a*Bravaismn)
    # (i k R) (i k R) ... (i k R) exp(i k R)
    @inline phdkn(Bravaismn) = (im^order) * ∏(coeff(dk,Bravaismn) for dk ∈ klist) * ph(Bravaismn)
    # multiply the coefficients from the derivative
    # to the corresponding matrix
    ∑(phdkn(mn).* matdic[mn] for mn ∈ keys(matdic))
end


# deal with (kx,kx,kz), (ky,kx,kx), etc
function collect_expansion(expan,eps)
    @inline sort_tuple(x) = Tuple(sort(collect(x)))
    m0  = 0.0 .* first(values(expan))
    ret = Dict( k=>m0 for k ∈ unique(sort_tuple.(sck(expan))) )
    for k ∈ keys(expan)
        @assert LinearAlgebra.norm(LinearAlgebra.Matrix(expan[k]).-LinearAlgebra.Matrix(expan[sort_tuple(k)])) < eps
        ret[sort_tuple(k)] += expan[k] # accumulate
    end
    ret1 = delete_empty(ret)
    return Dict(k=>(1//factorial(length(k))).*v for (k,v) ∈ ret1)
end


KvecDIC = Dict( :kx=>1, :ky=>2, :kz=>3 )

@inline Δk( q::Vector{Float64},
            K0::Vector{Float64},
            V::Tuple) = (length(V)==0 ? 1 : prod((q.-K0)[KvecDIC[v]] for v ∈ V))
